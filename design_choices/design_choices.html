<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Design choices</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.75.2">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Http">
<link rel="up" href="../design_choices.html" title="Chapter&#160;4.&#160;Design choices">
<link rel="prev" href="../design_choices.html" title="Chapter&#160;4.&#160;Design choices">
<link rel="next" href="roadmap.html" title="Roadmap">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../design_choices.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../design_choices.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="roadmap.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="design_choices.design_choices"></a><a class="link" href="design_choices.html" title="Design choices">Design choices</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="design_choices.html#design_choices.design_choices.the_what">The what</a></span></dt>
<dt><span class="section"><a href="design_choices.html#design_choices.design_choices.asio_familiarity">ASIO
        familiarity</a></span></dt>
<dt><span class="section"><a href="design_choices.html#design_choices.design_choices.the_mysterious_weird_news_api">The
        mysterious/weird/news API</a></span></dt>
<dt><span class="section"><a href="design_choices.html#design_choices.design_choices.the_why">The why</a></span></dt>
<dt><span class="section"><a href="design_choices.html#design_choices.design_choices.the_when">The when</a></span></dt>
</dl></div>
<p>
        To convince you about the solution, I'll start the text highlighting some
        problems and requirements. If you understand the problem, you'll understand
        why the solution was proposed like that.
      </p>
<p>
        One of the wanted features for this library since the very beginning was
        to make it possible to make a small change in code to expose the HTTP service
        through a different communication mechanism. Like, change from embedded HTTP
        server to FastCGI-exposed server.
      </p>
<p>
        There are several libraries who will provide some object you can use to consume
        HTTP traffic from the world and will act as a request-reply door to create
        web applications. Libraries who will expose a request object you can use
        to consume TCP traffic and will export url and headers properties. The problem
        with this approach is the coupling between HTTP messages and HTTP communication
        channels.
      </p>
<p>
        In Boost.Http, HTTP messages and HTTP communication channels are decoupled,
        so it is easier to replace the communication channel later. You could easily
        use an unprotected embedded HTTP server on development environment to tests
        and replace it in favor of a full-blow solution during production.
      </p>
<p>
        Boost.Http defines some type requirements to abstract communication channels
        and provide some polymorphic adapters who will type erase them. The abstraction
        was specified carefully to allow robust applications. Your application will
        not hang trying to live stream a video because the request was done from
        an <code class="computeroutput"><span class="identifier">HTTP</span><span class="special">/</span><span class="number">1.0</span></code> client. Also, your handler won't know what
        HTTP version (if any) the HTTP request was made with.
      </p>
<p>
        Also among the wanted features was to retain the usefulness of the library
        whether you're using it to power an application intended to run from an low-end
        embedded device or an application intended to run on a cluster with plenty
        of resources to be made use of. An embdeded device may not have the luxury
        to host a pool or a cache layer, but a cluster may even demand these layers
        to properly handle thousands of requests every second. With this use case
        in mind, modularity was achieved.
      </p>
<p>
        The plan to finish such ambitious project was <span class="quote">&#8220;<span class="quote">to expose an HTTP abstraction
        able to make use of the HTTP power (chunking/streaming, pipelining, upgrade
        for supporting channels and multiplexing for supporting channels), at the
        same time that a complete separation of communication channels and HTTP messages
        is achieved</span>&#8221;</span>.
      </p>
<p>
        With the separation of HTTP messages and HTTP communication channels, alongside
        the use of an active model (you ask by the next request instead providing
        a handler and waiting for them), several of the requirements became very
        easy to fulfill, such as HTTP pipelining, custom memory allocation, buffers,
        cache layers and pools of objects.
      </p>
<p>
        With such very generalized abstractions, you may be worried about the need
        to type too much to get something done. This is being solved by providing
        higher level flexible abstractions, such as the file server you can already
        find.
      </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="design_choices.design_choices.the_what"></a><a class="link" href="design_choices.html#design_choices.design_choices.the_what" title="The what">The what</a>
</h3></div></div></div>
<p>
          <span class="inlinemediaobject"><object type="image/svg+xml" data="../request%20handling.svg"></object></span>
        </p>
<p>
          The above image shows an overview of how to build HTTP servers using Boost.Http.
        </p>
<p>
          Let's assume you're going to use the provided <code class="computeroutput"><span class="identifier">http</span><span class="special">::</span><span class="identifier">socket</span></code>,
          suitable for embedding HTTP servers in your application.
        </p>
<p>
          You must instantiate a TCP socket acceptor and accept new connections.
          You should handle all connections concurrently.
        </p>
<p>
          Each connection you handle is a pipeline of request-reply pair. To receive
          the full request, your action may be required at several points. First,
          you should receive the request metadata, then it may be necessary to issue
          a 100-continue response. Then you need to issue reads for the body and
          the trailers until the whole request has been received.
        </p>
<p>
          You're finally able to send the reply. You have two options, atomic messages
          or chunked messages. Chunked messages are not always available and must
          check if they can be used for each request you receive, using <code class="computeroutput"><span class="identifier">write_response_native_stream</span><span class="special">()</span></code>.
        </p>
<p>
          If you spread the handling logic among several functions, a good approach
          would be to always share the triplet <code class="computeroutput"><span class="special">&lt;</span><span class="identifier">communication</span> <span class="identifier">channel</span><span class="special">,</span> <span class="identifier">request</span> <span class="identifier">message</span><span class="special">,</span> <span class="identifier">response</span> <span class="identifier">message</span><span class="special">&gt;</span></code> around.
        </p>
<p>
          Still missing is URL parsing and request routing, so you must do this yourself,
          possibly managing pools of message and socket objects.
        </p>
<p>
          This system allows you to implement powerful schedulers doing fair share
          of resources over different IPs, whether the requests originate from HTTP
          or HTTPS, using all cores of your CPU and deferring new work when the work
          load is too high. You should be able to do all fine-grained tuning you
          need and also easily create higher level that are suitable for your application.
          Not only that, this library could become an interoperability layer for
          all higher-level that web application developers create.
        </p>
<p>
          <span class="inlinemediaobject"><object type="image/svg+xml" data="../request.svg" width="629.991625" height="119.115775"></object></span>
        </p>
<p>
          Also, if you pay attention, you'll realize that this proposal just expose
          HTTP with a message oriented abstraction. All procedures in the diagram
          are related to HTTP events and actions. And this is a modern API and you
          can use pretty much every modern HTTP feature (persistent streams &amp;
          HTTP pipelining, chunked entities, 100-continue status, ...). And you won't
          handle any parsing or low-level detail at all. It's abstracted enough to
          allow alternative backends.
        </p>
<p>
          However, this can easily become a callback hell, and futures wouldn't help
          much, given the need to use <code class="computeroutput"><span class="keyword">while</span></code>-constructs.
          If you use coroutines, there is hope your code will be readable. Boost.Http
          follows Asio extensible asynchronous model and you're free to use callbacks,
          futures, coroutines or others.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="design_choices.design_choices.asio_familiarity"></a><a class="link" href="design_choices.html#design_choices.design_choices.asio_familiarity" title="ASIO familiarity">ASIO
        familiarity</a>
</h3></div></div></div>
<p>
          This library may be very pleasant to use for any ASIO-centered mind.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Completion tokens received as the last argument for aync functions.
            </li>
<li class="listitem">
              Async operations have the <code class="computeroutput"><span class="identifier">async_</span></code>
              prefix.
            </li>
<li class="listitem">
              User control the bufferring mechanism, passing the opaque asio::buffer
              type.
            </li>
<li class="listitem">
              User provides <span class="emphasis"><em>output</em></span> arguments as references and
              they'll be "filled" by the time the operation completes.
            </li>
<li class="listitem">
              Memory management is left for the user.
            </li>
<li class="listitem">
              An active model is presented.
            </li>
<li class="listitem">
              Similar nomenclature.
            </li>
</ul></div>
<p>
          <span class="emphasis"><em>The ASIO way</em></span> saved us from many problems that otherwise
          would force us to propose solutions to already know problems such as:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Object pools.
            </li>
<li class="listitem">
              Deferring acceptance to later on high load scenarios.
            </li>
<li class="listitem">
              HTTP pipelining problems.
            </li>
<li class="listitem">
              Partially filling response objects from different layers of abstractions.
            </li>
<li class="listitem">
              A wrapping/wrapped socket can take care of tasks such as synchronization/queueing
              and timeout.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="design_choices.design_choices.the_mysterious_weird_news_api"></a><a class="link" href="design_choices.html#design_choices.design_choices.the_mysterious_weird_news_api" title="The mysterious/weird/news API">The
        mysterious/weird/news API</a>
</h3></div></div></div>
<p>
          One of the maybe surprising things to start with is the use of highly structured
          objects as opposed to things like opaque buffers. You pass a message object
          to the initiating function and you'll have a fully decomposed object with
          an URL, a method and even an associative container for the headers!!!
        </p>
<p>
          If you do have special memory requirements for the messages, you're free
          to implementing an alternative container, as long as it fulfills the documented
          <code class="computeroutput"><span class="identifier">Message</span></code> concept. Connections
          channels and HTTP messages are <span class="bold"><strong>not</strong></span> coupled
          together. You can reuse these pieces in many many different contexts.
        </p>
<p>
          The uncoupled architecture is more general and it is the default mode,
          but let's say you work at a more constrained environment where memory copying
          is banned, for instance. You could provide your HTTP backend (e.g. a non-copying
          embedded server) tied to your specific HTTP message type implementing our
          ideas and you still may benefit from this libray. This library provides
          some HTTP algorithms and some HTTP algorithms (e.g. file server) and these
          abstractions will save some time from you.
        </p>
<p>
          Another difference in this library is the presence of an associated state
          for reading and writing messages. I believe this abstraction can be extended
          to also support very simple HTTP clients. To avoid confusion, if some member-function
          cannot be used for both modes (clients and servers), it'll have one of
          the following prefixes:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              async_read_request
            </li>
<li class="listitem">
              async_read_response
            </li>
<li class="listitem">
              async_write_request
            </li>
<li class="listitem">
              async_write_response
            </li>
</ul></div>
<p>
          We gave special attention to <code class="computeroutput"><span class="identifier">read_state</span></code>
          and <code class="computeroutput"><span class="identifier">write_state</span></code> to make
          sure it'll also be usable for <span class="bold"><strong>simple</strong></span> and
          asynchronous HTTP clients.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="design_choices.design_choices.the_why"></a><a class="link" href="design_choices.html#design_choices.design_choices.the_why" title="The why">The why</a>
</h3></div></div></div>
<p>
          Boost.Http provides an HTTP socket, which can be used to manage a pipeline
          of HTTP messages (i.e. an HTTP request or an HTTP reply). HTTP is stateless
          and each message coming from the same socket is independent. The HTTP socket
          from Boost.Http is a concept and specific implementations from this concept
          may provide more guarantees about the communication properties. The reasons
          to provide few guarantees are (<code class="computeroutput"><span class="special">#</span><span class="number">1</span></code>) because we want a common denominator from
          which we can provide implementation for multiple communication channels
          and (<code class="computeroutput"><span class="special">#</span><span class="number">2</span></code>)
          because implementation details are usually not required for the application,
          which is only interested in a high-level abstraction. The provided <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">http</span><span class="special">::</span><span class="identifier">basic_socket</span></code> implementation will handle
          actual HTTP traffic from TCP sockets and you can use it to handle <code class="computeroutput"><span class="identifier">HTTP</span><span class="special">/</span><span class="number">1.0</span></code> and <code class="computeroutput"><span class="identifier">HTTP</span><span class="special">/</span><span class="number">1.1</span></code> traffic
          from TCP and SSL sockets.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">read_state</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">write_state</span><span class="special">()</span></code>
          are used to inspect the current state of interaction and react appropriately.
          There are rules regarding when the socket can mutate and change its states.
          Once you request the socket to read a new HTTP request, you'll be notified
          as soon as the request metadata (request line and HTTP headers) are ready,
          then you can progressively download the body and react appropriately. This
          idea is very useful to improve communication between the library authors
          and application authors and also helps to create some tests.
        </p>
<p>
          You'll have to inspect the socket to know whether the current message-exchange
          requires <code class="computeroutput"><span class="number">100</span><span class="special">-</span><span class="keyword">continue</span></code>, allows chunked entities (streaming
          response) and alike. There is like two kind of replies. With atomic replies,
          you write the whole message at once. With chunked message, you compose
          a message spreading its construction among several API calls. You may want
          to use chunked messages when you don't know the whole body in advance (e.g.
          reading a file, video live stream...), but chunked messages can only be
          used in certain message exchanges. The reason behind providing two kind
          of replies is to properly support a wider range of HTTP communication channels.
        </p>
<p>
          You create one HTTP socket for each HTTP client and should handle them
          all concurrently. In case you're using the embeddable HTTP server backend,
          you must use an acceptor to initialize the <code class="computeroutput"><span class="identifier">basic_socket</span></code>s'
          <code class="computeroutput"><span class="identifier">next_layer</span><span class="special">()</span></code>
          and then consume them. <code class="computeroutput"><span class="identifier">basic_socket</span></code>
          templatize the underlying internal socket, so you can use SSL, queue wrapping
          socket (to work around Asio's composed operations) and so on. The intention
          of Boost.Http is not only to generalize over data structures and HTTP backends,
          but about any place where it may be helpful.
        </p>
<p>
          The choice to represent the HTTP messages in separate objects and the whole
          combination of this design ease supports for HTTP pipelining a lot. In
          passive styles, a request is generated and generated and you must act on
          them. In this active style, you explicitly request the next message, handle
          it and then request another one. In this scenario, two unrelated messages
          won't be mixed up, because you won't see the next message while you don't
          handle the current one. The read and write states gives a mean to communicate
          how to use the API and how to detect some logical errors in the application.
        </p>
<p>
          The choice to hide details from the HTTP connection (HTTP version, socket
          object...) was done to properly support multiple backends. The ability
          to query certain properties from the underlying communication channel is
          necessary to achieve reliability under this model. A lot of responsibilies
          and expected behaviour is documented on the type requirements for <code class="computeroutput"><span class="identifier">ServerSocket</span></code> objects.
        </p>
<p>
          A C++11 multimap is used to represent HTTP headers because that's what
          HTTP headers conceptually are. HTTP spec specifies you must handle HTTP
          header elements with equivalent keys as if there was a single header where
          the values are joined with commas. Some old headers don't work with this
          approach and their values, when multiple elements with equivalent keys
          are present, must be stored separately. The order matters, just as the
          C++11 definition of multimap.
        </p>
<p>
          Runtime-based polymorphic behaviour isn't used by default, because not
          all projects are willing to pay for this price. Well defined type requirements
          are provided and some polymorphic adaptors will convert models of these
          type requirements to classes inheriting a single specific abstract base
          class.
        </p>
<p>
          Member-functions as opposed to member-variables are used in HTTP messages,
          because some setup (e.g. a proxy who doesn't want to reformat the messages)
          may want to move the HTTP parser to the HTTP message object. I want to
          allow a library who will beat C servers in every aspect.
        </p>
<p>
          For type safety sake, the HTTP first line (request line or response's status
          line) isn't part of the HTTP message object, as its attributes are variant.
        </p>
<p>
          As per <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2" target="_top">RFC
          7230</a>, <span class="quote">&#8220;<span class="quote">a server MUST NOT apply a request to the target resource
          until the entire request header section is received, since later header
          fields might include conditionals, authentication credentials, or deliberately
          misleading duplicate header fields that would impact request processing</span>&#8221;</span>,
          so we define an interface who will only expose a message once the complete
          header section is ready. The message body can be progressively received
          later. The API also unifies HTTP messages and HTTP chunking.
        </p>
<p>
          URL-decomposed objects aren't used because all an HTTP backend needs is
          some string-like container to push bytes. This container can implement
          an in-place URL parsing algorithm and it is all solved. The generic HTTP
          backends you find in Boost.Http won't care about the url concrete type
          and you don't need to expect any barrier from this side.
        </p>
<p>
          We do not use the message itself as a buffer object while we're parsing
          the connection stream. We require a separate buffer to be able to properly
          handle HTTP pipelining (and futurely multiplexing in <code class="literal">HTTP/2.0</code>).
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="design_choices.design_choices.the_when"></a><a class="link" href="design_choices.html#design_choices.design_choices.the_when" title="The when">The when</a>
</h3></div></div></div>
<p>
          I couldn't resist the temptation of adding a <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>when</em></span></span>&#8221;</span>
          named section after I already had written a <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>what</em></span></span>&#8221;</span>
          and a <span class="quote">&#8220;<span class="quote"><span class="emphasis"><em>why</em></span></span>&#8221;</span> section.
        </p>
<p>
          Just too much research time went into this proposal. Really, a lot of time.
          I developed some broken HTTP projects some years ago, learned a lot of
          design with really different approaches (PHP, Django, Node.js) trying to
          solve this problem, developed my own serious project (<a href="https://github.com/vinipsmaker/tufao" target="_top">Tuf&#227;o</a>)
          and continued to study and research a lot (the HTTP spec resurrection project,
          or RFC7230, helped <span class="bold"><strong>a lot</strong></span>). I've gathered
          info around where interoperability may be a problem if API doesn't help
          and what features will be desired, sooner or later, by users, among other
          data. I've done real effort to gather feedback from C++ programmers for
          quite a while already.
        </p>
<p>
          A special thanks to Bj&#248;rn Reese for mentoring me on Asio quirks and API
          general design, the feedback which changed the proposal the most. Also
          a special thanks to any friend who helped to maintain my mind at a happy
          state.
        </p>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2014, 2015 Vin&#237;cius dos Santos Oliveira<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../design_choices.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../design_choices.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="roadmap.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
